import pandas as pd
import numpy as np
from sklearn.model_selection import cross_val_score, StratifiedKFold
from sklearn.preprocessing import LabelEncoder, OneHotEncoder, StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.metrics import accuracy_score
from sklearn.linear_model import LogisticRegression, Perceptron, SGDClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC, LinearSVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import GaussianNB

def extract_title(df):
    df['Title'] = df['Name'].str.extract(r',\s*([^.]*)\.', expand=False).str.strip()
    rare = ['Lady','Countess','Capt','Col','Don','Dr','Major','Rev','Sir','Jonkheer','Dona']
    df['Title'] = df['Title'].replace(['Mlle','Ms'],'Miss')
    df['Title'] = df['Title'].replace(['Mme'],'Mrs')
    df['Title'] = df['Title'].apply(lambda x: 'Rare' if x in rare else x)
    return df

def basic_preprocess(df):
    df = df.copy()
    df = extract_title(df)
    df['FamilySize'] = df['SibSp'] + df['Parch'] + 1
    df['IsAlone'] = (df['FamilySize'] == 1).astype(int)
    df['Embarked'] = df['Embarked'].fillna(df['Embarked'].mode()[0])
    df['Fare'] = df['Fare'].fillna(df['Fare'].median())
    df['Age'] = df['Age'].fillna(df['Age'].median())
    df['Sex'] = df['Sex'].map({'male':0, 'female':1}).astype(int)
    df['Title'] = LabelEncoder().fit_transform(df['Title'].astype(str))
    df = df.drop(['PassengerId','Name','Ticket','Cabin'], axis=1, errors='ignore')
    return df

def improved_preprocess(df, fit_age_model=None):
    df = df.copy()
    df = extract_title(df)
    df['FamilySize'] = df['SibSp'] + df['Parch'] + 1
    df['IsAlone'] = (df['FamilySize'] == 1).astype(int)
    df['Fare'] = df['Fare'].fillna(df['Fare'].median())
    df['Embarked'] = df['Embarked'].fillna(df['Embarked'].mode()[0])
    df['Age'] = df['Age'].fillna(df.groupby(['Title','Pclass'])['Age'].transform('median'))
    df['Age'] = df['Age'].fillna(df['Age'].median())
    df['FarePerPerson'] = df['Fare'] / df['FamilySize']
    df['AgeBin'] = pd.cut(df['Age'], bins=[0,12,20,40,60,100], labels=False)
    df['CabinDeck'] = df['Cabin'].astype(str).str[0].replace('n','Unknown')
    df['Sex'] = df['Sex'].map({'male':0, 'female':1}).astype(int)
    df['Title'] = LabelEncoder().fit_transform(df['Title'].astype(str))
    df['CabinDeck'] = LabelEncoder().fit_transform(df['CabinDeck'].astype(str))
    df = df.drop(['PassengerId','Name','Ticket','Cabin'], axis=1, errors='ignore')
    return df

train = pd.read_csv('train.csv')
test = pd.read_csv('test.csv')

train_basic = basic_preprocess(train)
X_basic = train_basic.drop('Survived', axis=1)
y = train_basic['Survived']

train_improved = improved_preprocess(train)
X_improved = train_improved.drop('Survived', axis=1)

models = {
    'SVM': SVC(kernel='rbf', gamma='scale'),
    'KNN': KNeighborsClassifier(n_neighbors=5),
    'Logistic Regression': LogisticRegression(max_iter=200),
    'Random Forest': RandomForestClassifier(n_estimators=100, random_state=42),
    'Naive Bayes': GaussianNB(),
    'Perceptron': Perceptron(),
    'SGD': SGDClassifier(max_iter=1000, tol=1e-3),
    'LinearSVC': LinearSVC(max_iter=5000),
    'Decision Tree': DecisionTreeClassifier(random_state=42)
}

cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

def evaluate_models(X, y, models, scale=False):
    results = {}
    for name, model in models.items():
        if scale:
            from sklearn.pipeline import make_pipeline
            pipe = make_pipeline(StandardScaler(), model)
            scores = cross_val_score(pipe, X, y, cv=cv, scoring='accuracy', n_jobs=-1)
        else:
            scores = cross_val_score(model, X, y, cv=cv, scoring='accuracy', n_jobs=-1)
        results[name] = (scores.mean(), scores.std())
    return results

print("\nEvaluating improved preprocessing")
X_imp = X_improved.copy()
X_imp = pd.get_dummies(X_imp, drop_first=True)
results_improved = evaluate_models(X_imp, y, models, scale=True)
for m,(mu,sd) in results_improved.items():
    print(f"{m:20s}: {mu:.4f} Â± {sd:.4f}")
